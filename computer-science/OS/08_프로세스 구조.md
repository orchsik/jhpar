### 프로세스 구조

- 프로세스(process)는 일반적으로 어떻게 구성되어 있을까?

  - text(CODE): 코드
  - data: 변수/초기화 된 데이터
  - stack: 임시 데이터(함수호출, 로컬 변수 등)
  - heap: 코드에서 동적으로 만들어지는 데이터
  <center>
  <image src='./images/process-structure.png' width=180 />
  <image src='./images/process-structure-2.png' width=500 />
  </center>

---

- PC(Program Counter) + SP(Stack Pointer)
  - cf) EBP 레지스터: 항상 최상단 비어있는 stack 주소를 값을 갖는다. 에러발생시 추적에 용이하도록
  - cf) EAX 레지스터: return 값이 들어간다.
  <center><image src='./images/process-structure-3.png' /></center>
  <center><image src='./images/process-structure-4.png' /></center>

---

### Heap 이란?

- 동적메모리 할당
  <image src='./images/process-heap.png' />
  <image src='./images/process-heap-2.png' />

---

### 프로세스 구조: Stack, Heap, DATA(BSS, DATA), TEXT(CODE)

> DATA를 BSS와 DATA로 분리

- 초기값을 할당한 변수는 DATA 에 할당
- 초기값을 할당하지 않은 변수는 BSS 에 할당
  <center><image src='./images/process-bss-data.png'  /> </center>

---

### 프로세스와 컨텍스트 스위칭

> 다시 PC, SP 에 주목하자

- PC(Program Counter) + SP(Stack Pointer)

  > Stack, HEAP, DATA(BSS, DATA), TEXT(CODE)

  - A 프로그램
  <center><image src='./images/process-pc-sp-1.png' width=800/> </center>

  - Context Switching

    1. 컨텍스트 스위칭 전에 ProcessA의 PCB 에 CPU에서 running 중인 PC, SP 를 저장.
    2. ProcessB의 PCB 에 저장된 PC, SP 로 CPU Context를 업데이트 해서 프로세스 진행.
    3. 다시 ProcessA 프로세스 진행할 때 ProcessA PCB의 값을 CPU Context에 넣어서 프로세스 진행.
    <center>
    <image src='./images/context-switching.png' width=300 />
    <image src='./images/pcb.png' width=300 />
    </center>

  - B 프로그램
  <center><image src='./images/process-pc-sp-2.png' width=500 /> </center>

---

### PCB

> PC, SP 는 어디에 저장하나?

### Process Control Block (PCB)에 저장!

> Process Context Block 이라고도 함.

1. Process ID
2. Register 값(PC, SP 등)
3. Scheduling Info (Process State)
4. Memory Info (메모리 사이즈 limit)
   ...

> PCB: 프로세스가 실행중인 상태를 캡쳐/구조화해서 저장

<center><image src='./images/PCB-linux.png' width=500 /></center>

---

### 정리

- 프로세스 구조

  - Stack, HEAP, DATA(BSS, DATA), TEXT(CODE)

- PCB (Program Context(Contorl) Block)
  - 프로세스 상태 정보 - PC, SP, 메모리, 스케쥴링 정보 등
