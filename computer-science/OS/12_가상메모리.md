## 가상메모리

---

### 가상메모리(Virtual Memory System)

> 실제 각 프로세스마다 충분한 메모리를 할당하기에는 메모리 크기가 한계가 있음

- 예: 리눅스는 하나의 프로세스가 4GB 임
- 통상 메모리는 8GB 또는 16GB 인데 그럼 2~4개 밖에 못 돌림!? 어떻게 함 ㅜㅜ
- 가상메모리를 알아보자!

> 폰노이만 구조 기반이므로 코드는 메모리에 반드시 있어야 함

---

### 가상메모리 구동원리

- 프로세스가 한번에 4GB를 모두 사용하는 것은 아니므로 작동중인 부분의 메모리만 실제 메모리에 올리는 스타일~
  <center><image src='./images/virtualmemory.png' /></center>

---

### 가상메모리가 필요한 이유

- 여러 프로세스 동시 실행 시스템

  1. 메모리 용량 부족 이슈
  2. 프로세스 메모리 영역간 침범 이슈

- 하나의 프로세스만 실행 가능한 시스템(배치 처리 시스템 등): 가상메모리 거의 필요없음

---

### 가상메모리

- 가상메모리: 메모리가 실제 메모리 보다 많아 보이게 하는 기술
  - 실제 사용하는 메모리는 작다는 점에 착안해서 고안된 기술
  - 프로세스 공간 분리로 프로세스 이슈가 전체 시스템에 영향을 주지 않을 수 있음

---

### 가상 메모리(Virtual Memory System)

- 가상 메모리 기본 아이디어
  - 프로세스는 가상 주소를 사용하고 실제 해당 주소에서 데이터를 읽고 쓸 때만 물리 주소를 사용하면 된다.
  - virtual address(가상주소): 프로세스가 참조하는 주소 (0~4GB)
  - physical address(물리주소): 실제 메모리 주소
- MMU(Memory Management Unit)
  - CPU에 코드 실행시 가상 주소 메모리 접근이 필요할 때, 해당 주소를 물리 주소값으로 변환해주는 하드웨어 장치

---

### 가상메모리(Virtual Memory System)와 MMU

- CPU는 가상메모리를 다루고 실제 해당 주소 접근시 MMU 하드웨어 장치를 통해 물리 메모리 접근
  - 하드웨어 장치를 이용해야 주소 변환이 빠르기 때문에 별도 장치를 둠
  <center><image src='./images/MMU.png' width=400 /></center>

---

### 페이징 시스템(paging system)

- 페이징(paging) 개념
  - 크기가 동일한 페이지로 가상 주소 공간과 이에 매칭하는 물리 주소 공간을 관리
    - 가상메모리를 물리메모리로 변환시키는 크기(한 페이지)를 정하고 번호를 부여함
  - 하드웨어 지원이 필요
    - 예) Intel x86 시스템(32bit)에서는 4KB, 2MB, 1GB 지원
  - 리눅스에서는 4KB로 paging
  - 페이지 번호를 기반으로 가상 주소, 물리 주소 매핑 정보 기록/사용

---

### 페이징 시스템(paging system)

> 실질적인 예를 기반으로 페이징 시스템에 대해 알아보자

- 프로세스(4GB)의 PCB에 Page Table 구조체를 가리키는 주소가 들어있음
- Page Table에는 가상 주소와 물리주소간 매핑 정보가 있음
  <center><image src='./images/pagetable.png' width=400/></center>

---

### 페이징 시스템 구조

- page 또는 page frame: 고정된 크기의 block (4KB)
- paging system

  - 가상 주소 v = (p, d)
    - p: 가상 메모리 페이지
    - d: p 안에서 참조하는 위치
    <center><image src='./images/pagingsystem1.png' width=400/></center>

- 페이지 크기가 4KB 예시
  - 가상 주소의 0비트에서 11비트가 변위(d)를 나타내고,
  - 12비트 이상이 페이지 번호가 될 수 있음

---

### 페이지 테이블(page table)

- page table

  - 물리 주소에 있는 페이지 번호와 해당 페이지의 첫 물리주소 정볼를 매핑한 표
  - 가상주소 v = (p, d) 라면
    - p: 페이지번호
    - d: 페이지 처음부터 얼마 떨어진 위치인지

- paging system 동작
  - 해당 프로세스에서 특정 가상 주소 엑세스를 하려면
    - PCB를 통해 해당 프로세스의 page table에 해당 가상주소가 포함된 page 번호가 있는지 확인
    - page 번호가 있으면 이 page가 매핑된 첫 물리주소를 알아내고(p`)
    - p` + d 가 실제 물리주소가 됨
    <center><image src='./images/pagingsystem.png' width=400/></center>

---

### paging system

<center><image src='./images/pagingsystem2.png' /></center>

---

### 페이징 시스템과 MMU(컴퓨터 구조)

- CPU는 가상 주소 접근시
  MMU 하드웨어 장치를 통해 물리 메모리 접근
  <center><image src='./images/MMU.png' width=400 /></center>

- 프로세스 생성시 페이지 테이블 정보 생성
  - PCB 등 에서 해당 페이지 테이블 접근 가능하고 관련 정보는 물리 메모리에 적재
  - 프로세스 구동 시, 해당 페이지 테이블 base 주소가 별도 레지스터에 저장(CR3)
  - CPU가 가상 주소 접근시, MMU가 페이지 테이블 base 주소를 접근해서 물리 주소를 가져옴
