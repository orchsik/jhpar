## 프로세스 관리 - 프로세스 생성

---

### 프로세스 기본 구조

- TEXT, DATA, BSS, HEAP, STACK
<center><image src='./images/processstructure.png' width=600 /></center>

---

### 프로세스 생성

- 기본 프로세스 생성 과정
  1. TEXT, DATA, BSS, HEAP, STACK의 공간을 생성
  2. 프로세스 이미지를 해당 공간에 업로드하고 실행 시작
- 프로세스 계층: 다른 프로세스는 또 다른 프로세스로부터 생성
  - 부모 프로세스, 자식 프로세스

---

### fork()와 exec() 시스템콜

- fork() 시스템콜
  - 새로운 프로세스 공간을 별도로 만들고 fork() 시스템콜을 호출한 프로세스(부모 프로세스) 공간을 모두 복사
    - 별도의 프로세스 공간을 만들고, 부모 프로세스 공간의 데이터를 그대로 복사
- exec() 시스템콜
  - exec() 시스템콜을 호출한 현재 프로세스 공간의 TEXT, DATA, BSS 영역을 새로운 프로세스의 이미지로 덮어씌움
    - 별도의 프로세스 공간을 만들지 않음

---

### fork() 시스템콜

???

- 함수원형

```
헤더파일: <unistd.h>
함수원형: pid_t fork(void);
```

- 실습코드

```c
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
int main()
{
  pid_t pid;
  printf("Before fork() call\n");
  pid = fork();
  if (pid == 0)
    printf("This is Child process. PID is %d\n", pid);
  else if (pid > 0)
    printf("This is Parent process. PID is %d\n", pid);
  else
    printf("fork() is failed\n");
  return 0;
}
```

---

### fork() 시스템콜

- pid = fork()가 실행되면 부모 프로세스와 동일한 자식 프로세스가 별도의 메모리 공간에 생성
- 자식 프로세스는 pid가 0으로 리턴, 부모 프로세스는 실제 pid 리턴
- 두 프로세스의 변수 및 PC(Program Counter)값은 동일
- 새로운 프로세스 공간을 별도로 만들고 fork() 시스템콜을 호출한 프로세스(부모 프로세스) 공간을 모두 복사한 후, for() 시스템콜 이후 코드부터 실행

---

### exec() 시스템콜 familly

???

- 함수원형

```
헤더 파일: <unistd.h>
함수 원형:
int execl(const char *path, const char *arg, ...);
int execlp(const char *file, const char *arg, ...);
int execle(const char *path, const char *arg, ..., char * const envp[]);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execvpe(const char *file, char *const argv[], char *const envp[])
```

---

### execl()와 execlp() 시스템콜 사용법

```c
execl("디렉토리와 파일 이름을 합친 전체이름", "명령어 인수 리스트", "끝은 NULL로 끝나야함");

// 파일 이름을 해당 프로세스를 실행한 프로세스의 환경변수(path)를 검색함
execlp("파일 이름", "명령어 인수 리스트", "끝은 NULL로 끝나야 함");
```

- 명령어 인수 리스트
  - argv[0] = "ls"
  - argv[1] = "-al"

```c
execl("/bin/ls", "ls", "-al", NULL);

execlp("ls", "ls", "-al", NULL);
```

### execle() 시스템콜 사용법

```c
// 환경변수를 지정하고자 할 때
char *envp[] = {"USER=dave", "PATH=/bin", (char *)0};
execle("ls", "ls", "-al", NULL, envp)
```

---

### execv(), execvp(), execve() 시스템콜 사용법

```c
// 인수 리스트를 내용으로 하는 문자열 배열
char *arg[] = {"ls", "-al", NULL};
execv("/bin/ls", arg);

// 파일 이름을 해당 프로세스를 실행한 프로세스의 환경변수(path)를 검색함
// 인수 리스트를 내용으로 하는 문자열 배열
char *arg[] = {"ls", "-al", NULL};
execvp("ls", arg);

// 환경변수를 지정하고자 할 때
char *envp[] = {"USER=dave", "PATH=/bin", (char *)0};
// 인수 리스트를 내용으로 하는 문자열 배열
char *arg[] = {"ls", "-al", NULL};
execve("ls", arg, envp);
```

### exec() 시스템콜 familly 정리

<center><image src='./images/exec-familly.png' width=650 /></center>

---

### execl() 시스템콜 예

```c
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
int main()
{
  printf("execute ls\n");
  execl("/bin/ls", "ls", "-l", NULL);
  perror("execl is failed\n");
  exit(1);
}
```

---

### execve() 시스템콜 예

- 환경변수를 새로 생성하므로 기존 사용자가 설정한 환경변수값은 사용할 수 없음
  - 다음 코드에서 envp에는 PATH를 설정하지 않았으므로 execve()에서 "/bin/ls"로 전체 경로를 써야 실행 가능

```c
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
int main()
{
  char *envp[] = {"USER=DAVE", NULL};
  char *arg[] = {"ls", "-al" , NULL};
  printf("execute ls\n");
  execve("/bin/ls", arg, envp);
  perror("execl is failed\n");
  exit(1);
}
```

---

### execl() 시스템콜 예

- execl() 시스템콜을 실행시킨 프로세스 공간에 새로운 프로세스 이미지를 덮어씌우고 새로운 프로세스를 실행시킴
- perror() 함수가 호출된다는 의미는 새로운 프로세스 이미지로 덮어씌우는 작업이 실행되지 못 했다는 의미. 즉, execl() 시스템콜 실행 실패

---

### for()와 exec()

- 리눅스 프로세스 실행
  1. 부모 프로세스로부터 새로운 프로세스 공간을 만들고 부모 프로세스 데이터 복사(fork)
  2. 새로운 프로세스를 위한 바이너리를 새로운 프로세스 공간에 덮어씌움(exec)

---

### wait() 시스템콜

- wait() 함수를 사용하면 fork() 함수 호출시, 작은 프로세스가 종료할 때까지 부모 프로세스가 기다림
- 자식 프로세스와 부모프로세스 동기화, 부모프로세스가 자식 프로세스보다 먼저 죽는 경우를 막기 위해 사용(고아 프로세스)
<center><image src='./images/systemcall-wait.png' width=450 /></center>

---

### fork(), execl(), wait() 시스템콜

```c
int main() {
  int pid;
  int child_pid;
  int status;
  pid = fork();
  switch (pid) {
    case -1:
      perror("fork is failed\n");
      break;
    case 0:
      execl("/bin/ls", "ls", "-al", NULL);
      perror("execl is failed\n");
      break;
    default:
      child_pid = wait(NULL);
      printf("ls is complete\n");
      printf("Parent PID (%d), Child PID (%d)\n", getpid(), child_pid);
      exit(0);
  }
}
```

---

### fork(), execl(), wait() 시스템콜

- execl()만 사용하면 부모프로세스가 사라짐
- 이를 유지하기 위해 fork()로 새로운 프로세스 공간 복사 후, execl() 사용
- wait() 함수를 사용해서 부모 프로세스가 자식 프로세스가 끝날 때까지 기다릴 수 있음
  > 쉘 프로그램은 fork(), exec() 계열, wait() 함수를 기반으로 작성 가능!

---

### 리눅스 프로세스

- 프로세스당 4GB 가상 메모리 할당
<center><image src='./images/virtualMemory-linux.png' width=350 /></center>

---

### 리눅스 프로세스

- 사용자 (0~3GB), 커널(3~4GB)
<center><image src='./images/virtualMemory-linux-2.png' width=350 /></center>

> 실제로 커널에 할당된 가상 메모리는 프로세스간 공유

---

### copy-on-write

- fork()는 새로운 프로세스 공간 생성 후, 기존 프로세스 공간 복사

> 4GB를 복사한다면 프로세스 생성 시간이 오래 걸림

- 자식 프로세스 생성시, 부모 프로세스 페이지를 우선 사용
- 부모 또는 자식 프로세스가 해당 페이지를 읽기가 아닌 쓰기를 할 때 페이지를 복사하고 분리함
- 장점
  - 프로세스 생성시간을 줄일 수 있음
  - 새로 생성된 프로세스에 새롭게 할당되어야 하는 페이지 수 최소화

---

### copy-on-write (read시)

- 자식 프로세스 생성시, 부모 프로세스 페이지를 우선 사용
<center><image src='./images/copy-on-write.png' width=450 /></center>

---

### copy-on-write (write시)

- 부모 또는 자식 프로세스가 해당 페이지를 읽기가 아닌 쓰기 요청시, 페이지를 복사 및 분리
<center><image src='./images/copy-on-write-2.png' width=450 /></center>

---

### 프로세스 종료

- exit() 시스템콜: 프로세스 종료

```c
#include <stdlib.h>
void exit(int status);
```

- main 함수의 return 0; 와 exit(0); 의 차이는?
  - exit() 함수 : 즉시 프로세스를 종료함 (exit() 함수 다음에 있는 코드는 실행되지 않음)
  - return 0 : 단지 main() 이라는 함수를 종료함 - 단 main()에서 return 시, C언어 실행파일에 기본으로 포함된 \_start() 함수를 호출하게 되고 해당 함수는 결국 exit() 함수를 호출함
    - man() 함수에서 return 0;은 exit() 호출과 큰 차이가 없음

---

### exit() 시스템콜

- 부모 프로세스는 status & 0377 계산값으로 자식 프로세스 종료 상태 확인 가능

```c
#include <stdlib.h>
void exit(int status);
```

???

- 기본 사용 예

```c
exit(EXIT_SUCCESS); // EXIT_SUCCESS는 0
exit(EXIT_FAILURE); // EXIT_FAILURE는 1
```

---

### exit() 시스템콜

- exit() 시스템콜 주요 동작
  - atexit()에 등록된 함수 실행
  - 열려 있는 모든 입축력 스트림 버퍼 삭제
  - 프로세스가 오픈한 파일을 모두 닫음
  - tmpfile() 함수를 통해 생성한 임시 파일 삭제
    - 참고) tmpfile() : 임시 파일을 wb + (쓸 수 있는 이진파일 형태) 모드로 오픈 가능
    ```c
    #include <stdio.h>
    FILE *tmpfile(void);
    ```

---

### atexit() 함수

- 프로세스 종료시 실행될 함수를 등록하기 위해 사용
- 등록된 함수를 등록된 역순대로 실행

---

### atexit() 함수 예제

```c
int main(void) {
  void exithandling(void);
  void goodbyemessage(void);
  int ret;
  ret = atexit(exithandling);
  if (ret != 0) perror("Error in atexit\n");
    ret = atexit(goodbyemessage);
  if (ret != 0) perror("Error in atexit\n");
    exit(EXIT_SUCCESS);
}

void exithandling(void) {
  printf("exit handling\n");
}

void goodbyemessage(void) {
  printf("see you again!\n");
}
```

---

### wait() 시스템콜

- wait() 함수를 사용하면 fork() 함수 호출시, 자식 프로세스가 종료할 때까지 부모 프로세스가 기다림
- 자식 프로세스가 종료되면 좀비 프로세스가 되어 해당 프로세스 조사를 위한 최소 정보만 가지고 있는 상태가 됨
- 완전히 끝나면 해당 정보도 삭제되고 부모 프로세스에 SIGCHLD 시그널이 보내짐
<center><image src='./images/systemcall-wait.png' width=450 /></center>

---

### wait() 시스템콜

- wait() 리턴값

  - 에러가 발생한 경우

  ```c
  #include <sys/wait.h>
  pid_t wait (int *status)
  // 리턴값은 종료된 자식 프로세스의 pid
  ```

  - stuatus 정보를 통해 기본적인 자식 프로세스 관련 정보를 확인할 수 있음

  ```c
  int WIFEXITED(status)
  ```

---

```c
int main() {
  int pid;
  int child_pid;
  int status;
  pid = fork();
  switch(pid) {
    case -1:
      perror("fork is failed\n");
      break;
    case 0:
      execl("/bin/ls", "ls", "-al", NULL);
      perror("execl is failed\n");
      break;
    default:
      child_pid = wait(&status);
      if (WIFEXITED(status)) {
        printf("Child process is normally terminated\n")
      }
      exit(0);
  }
}
```
